<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Code and Image Showcase</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            padding: 0;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
        }

        header h1 {
            font-size: 2em;
        }

        section {
            margin-bottom: 40px;
        }

        img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }

        .left-align-image img {
            margin: 20px 0;
            float: left; /* Ensures the image is aligned left */
        }

        .intro {
            font-size: 1.2em;
            color: #555;
            margin-bottom: 20px;
            text-align: left;
        }

        pre {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
        }

        code {
            font-family: "Courier New", Courier, monospace;
            font-size: 1em;
        }
    </style>
</head>
<body>

<header>
    <h1>Python Code to Automate Generation of a PowerPoint Chart</h1>
</header>

<section>
    <p class="intro">This shows Python code I wrote to automate the production of a PowerPoint slide showing which
    Epics the team is working on organized by Business Entity (BE) Stakeholder.  The source data is read from our Snowflake database.
    The Epics are organized and sorted by priority and color-coded as a heatmap.</p>
</section>

<section class="left-align-image">
    <h2>PowerPoint Slide Produced</h2>
    <img src="images/epic_ppt_blurred.jpg" alt="PowerPoint Slide">
</section>

<section>
    <h2>Python Code</h2>
    <pre><code class="language-python">
import os
import pandas as pd
from pptx import Presentation
from pptx.util import Inches
from pptx.util import Pt
from pptx.enum.text import PP_ALIGN, MSO_ANCHOR
from pptx.dml.color import RGBColor
from datetime import datetime

import snowflake.connector
from snowflake.connector.pandas_tools import write_pandas 
import pyreadr

header_font_size = 14
cell_font_size = 12
font_to_use = 'Arial'
max_rows_show = 8

# Read in the Snowflake credentials
sf_creds = pyreadr.read_r("C://Users//beecher//OneDrive - Cisco//Documents//Omega//Snowflake//sf_cred.RData")

etl_username = sf_creds['etl_username'].iloc[0,0]
etl_passwd = sf_creds['etl_passwd'].iloc[0,0]

cnn = snowflake.connector.connect(
  user=etl_username, 
  password=etl_passwd, 
  account='cisco.us-east-1'
)

cnn.cursor().execute("USE ROLE CX_OMEGABI_ETL_ROLE")
cnn.cursor().execute("USE WAREHOUSE CX_OMEGABI_ETL_WH")
cnn.cursor().execute("USE DATABASE CX_DB")
cnn.cursor().execute("USE SCHEMA CX_OMEGABI_BR")

# Define the SQL statement
sql = """
SELECT
  EPIC_ID, EPIC_NAME_CUSTOM, IT_ELT_RANK, STAKEHOLDER
FROM CX_DB.CX_OMEGABI_BR.BR_CLPM_EPIC_VIEW
WHERE ACTIVE = 'Active'
"""
# Run the sql statement and return the results as a pandas dataframe
df = pd.read_sql(sql, cnn)

cnn.close()

df_orig = df.copy()

# Rename column IT_ELT_RANK to PRIORITY
df.rename(columns={'IT_ELT_RANK':'PRIORITY'}, inplace=True)

# Replace nan values in PRIORITY with 99999
df.fillna({'PRIORITY': 99999}, inplace=True)

# Convert PRIORITY to integer
df['PRIORITY'] = df['PRIORITY'].astype(int)

# Columns for the table
columns = ['Networking, Collab & Sec 1', 'Networking, Collab & Sec 2', 'CX', 'Ops', 'GTM', 'Finance/Legal']

# Create an empty DataFrame with the specified columns
df2 = pd.DataFrame(columns=columns)

# Function to truncate text to 50 characters and add "..." if truncated
def truncate_text(text, max_length=50):
    if len(text) > max_length:
        return text[:max_length - 3] + "..."
    return text

# Function to get the heatmap color based on the normalized value
def get_heatmap_color(value, min_value, max_value):
    normalized_value = 1 + (value - min_value) * 9 / (max_value - min_value)
    normalized_value = round(normalized_value)
    
    heatmap_colors = {
        1: RGBColor(0xE6, 0xF9, 0xE6),
        2: RGBColor(0xCC, 0xF2, 0xCC),
        3: RGBColor(0xB3, 0xEB, 0xB3),
        4: RGBColor(0x99, 0xE5, 0x99),
        5: RGBColor(0x80, 0xDE, 0x80),
        6: RGBColor(0x66, 0xD7, 0x66),
        7: RGBColor(0x4D, 0xD1, 0x4D),
        8: RGBColor(0x33, 0xCA, 0x33),
        9: RGBColor(0x1A, 0xC3, 0x1A),
        10: RGBColor(0x00, 0xBD, 0x00)
    }
    
    return heatmap_colors.get(min(normalized_value, 10), RGBColor(0xC0, 0xC0, 0xC0))

# Calculate the min and max values in the PRIORITY column
df_tmp = df[df['PRIORITY'] != 99999]
min_value = df_tmp['PRIORITY'].min()
max_value = df_tmp['PRIORITY'].max()

# Populate df2 based on the logic
for col in columns:
    if col == 'Networking, Collab & Sec 1' or col == 'Networking, Collab & Sec 2':
        filtered_df = df[df['STAKEHOLDER'].str.contains('Networking, Collab & Sec', case=False, na=False)]
        sorted_filtered_df = filtered_df.sort_values(by='PRIORITY')
        epic_names = [
            truncate_text(f"{priority}: {name}")
            for priority, name in zip(sorted_filtered_df['PRIORITY'], sorted_filtered_df['EPIC_NAME_CUSTOM'])
        ]
        if col == 'Networking, Collab & Sec 1':
            df2[col] = pd.Series(epic_names[:10])
        else:
            df2[col] = pd.Series(epic_names[10:20])
    elif col == 'Finance/Legal':
        filtered_df = df[df['STAKEHOLDER'].str.contains('Finance|Legal', case=False, na=False)]
        sorted_filtered_df = filtered_df.sort_values(by='PRIORITY')
        epic_names = [
            truncate_text(f"{priority}: {name}")
            for priority, name in zip(sorted_filtered_df['PRIORITY'], sorted_filtered_df['EPIC_NAME_CUSTOM'])
        ]
        df2[col] = pd.Series(epic_names)
    else:
        filtered_df = df[df['STAKEHOLDER'].str.contains(col, case=False, na=False)]
        sorted_filtered_df = filtered_df.sort_values(by='PRIORITY')
        epic_names = [
            truncate_text(f"{priority}: {name}")
            for priority, name in zip(sorted_filtered_df['PRIORITY'], sorted_filtered_df['EPIC_NAME_CUSTOM'])
        ]
        df2[col] = pd.Series(epic_names)

# Determine the maximum number of rows needed
max_rows = df2.apply(lambda x: x.dropna().shape[0]).max()

# Ensure all columns have the same number of rows by filling with NaN
df2 = df2.reindex(range(max_rows))

# Replace "99999" with an empty string in df2 (substring match)
df2 = df2.applymap(lambda x: x.replace("99999: ", "") if isinstance(x, str) else x)

# Create the note string for BEs with more than max_rows_show items
note_lines = []
networking_collab_sec_counted = False  # Flag to ensure we only add the note once for Networking, Collab & Sec

for col in columns:
    if 'Networking, Collab & Sec' in col and not networking_collab_sec_counted:
        # Combine the two columns for 'Networking, Collab & Sec'
        combined_items = df2['Networking, Collab & Sec 1'].dropna().shape[0] + df2['Networking, Collab & Sec 2'].dropna().shape[0]
        if combined_items > 2 * max_rows_show:
            hidden_items = combined_items - 2 * max_rows_show
            note_lines.append(f"Bottom {hidden_items} Priority items for Networking, Collab & Sec not shown")
        networking_collab_sec_counted = True  # Set the flag to True after processing
    elif 'Networking, Collab & Sec' not in col:
        num_items = df2[col].dropna().shape[0]
        if num_items > max_rows_show:
            hidden_items = num_items - max_rows_show
            note_lines.append(f"Bottom {hidden_items} Priority items for {col} not shown")

# Always start with the required note line
note_text = "Notes: Active Epics only; BE based on ELT Owner of Epic."

# If there are any additional notes, add them
if note_lines:
    additional_note = " The table has been limited to the first {} rows. ".format(max_rows_show) + "; ".join(note_lines)
    note_text += additional_note

# The slide can only show max_rows_show rows, so limit df2 to max_rows_show rows
df2 = df2.head(max_rows_show)

# Create a presentation object
prs = Presentation()
prs.slide_width = Inches(13.33)
prs.slide_height = Inches(7.5)

# Add a slide with a title and content layout
slide_layout = prs.slide_layouts[5]
slide = prs.slides.add_slide(slide_layout)

# Add a title and subtitle
title = slide.shapes.title

title.text = "BE / Function Priority Dashboard (Commerce PLT Requests)"

# Access the text frame of the title
text_frame = title.text_frame

# Set the font properties
for paragraph in text_frame.paragraphs:
    for run in paragraph.runs:
        run.font.name = font_to_use
        run.font.size = Pt(28)
        run.font.color.rgb = RGBColor(0x00, 0x51, 0xAF)

# Set the alignment to left
text_frame.paragraphs[0].alignment = PP_ALIGN.LEFT

# Decrease the height of the title text box
title_shape = title
title_shape.width = Inches(12)
title_shape.height = Inches(1)
title_shape.left = Inches(0.5)

# Define the margins and table dimensions
left_margin = Inches(0.25)
top_margin = Inches(0.8)
slide_width = prs.slide_width - Inches(0.25)
table_width = slide_width - left_margin * 1
table_height = Inches(1)

# Add a table to the slide
rows, cols = df2.shape
table = slide.shapes.add_table(rows + 1, cols, left_margin, top_margin, table_width, table_height).table

# Set column widths to be equal
col_width = int(table_width / cols)
for i in range(cols):
    table.columns[i].width = col_width

# Add the headers and set their font properties
for i, column in enumerate(columns):
    cell = table.cell(0, i)
    cell.text = column
    for paragraph in cell.text_frame.paragraphs:
        for run in paragraph.runs:
            run.font.name = font_to_use
            run.font.size = Pt(header_font_size)
    cell.text_frame.paragraphs[0].alignment = PP_ALIGN.CENTER

# Add the data to the table and set font properties for cell contents
for i in range(rows):
    for j in range(cols):
        cell = table.cell(i + 1, j)
        value = df2.iloc[i, j]
        cell.text = str(value) if pd.notna(value) else ""

        for paragraph in cell.text_frame.paragraphs:
            for run in paragraph.runs:
                run.font.name = font_to_use
                run.font.size = Pt(cell_font_size)
        
        if isinstance(value, str) and ": " in value:
            prefix = value.split(": ")[0]
            try:
                heat_value = int(prefix)
                cell.fill.solid()
                cell.fill.fore_color.rgb = get_heatmap_color(heat_value, min_value, max_value)
            except ValueError:
                cell.fill.solid()
                cell.fill.fore_color.rgb = RGBColor(0xFF, 0xFF, 0xFF)
        elif pd.isna(value) or value == "":
            cell.fill.solid()
            cell.fill.fore_color.rgb = RGBColor(0xC0, 0xC0, 0xC0)
        else:
            cell.fill.solid()
            cell.fill.fore_color.rgb = RGBColor(0xFF, 0xFF, 0xFF)

# Enable text wrapping for the cells
for row in table.rows:
    for cell in row.cells:
        cell.text_frame.word_wrap = True

# Add the note to the bottom of the slide
left = Inches(0.5)
top = prs.slide_height - Inches(0.75)
width = prs.slide_width - Inches(1)
height = Inches(0.5)

# Add a text box for the note
note_box = slide.shapes.add_textbox(left, top, width, height)
text_frame = note_box.text_frame
text_frame.word_wrap = True

# Add the note text
p = text_frame.add_paragraph()
p.text = note_text

# Set the font properties for the note text
p.font.name = font_to_use
p.font.size = Pt(9)
p.font.color.rgb = RGBColor(0x80, 0x80, 0x80)
p.font.italic = True

# Add a timestamp to the upper right corner of the slide
timestamp = datetime.now().strftime("Refreshed: %m/%d/%y")
left = prs.slide_width - Inches(3)
top = Inches(0.05)
width = Inches(3)
height = Inches(0.2)

# Add a text box for the timestamp
timestamp_box = slide.shapes.add_textbox(left, top, width, height)
text_frame = timestamp_box.text_frame
text_frame.word_wrap = True
text_frame.vertical_anchor = MSO_ANCHOR.TOP

# Clear any existing paragraphs
text_frame.clear()

# Directly set the text of the text frame
p = text_frame.paragraphs[0]
p.text = timestamp

# Set the font properties for the timestamp text
p.font.name = font_to_use
p.font.size = Pt(10)
p.font.color.rgb = RGBColor(0x80, 0x80, 0x80)
p.alignment = PP_ALIGN.RIGHT

# Save the presentation
os.chdir('C:\\Users\\beecher\\Cisco\\Commerce Lifecycle Product Team - Backlog\\Portfolio Report Content')
prs.save('be_priority_dashboard.pptx')

    </code></pre>
</section>

</body>
</html>

